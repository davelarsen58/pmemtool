#!/usr/bin/python

# PMTOOL (pmt)
# Copyright (C) David P Larsen
# Released under MIT License


import sys
import os
import argparse

global VERBOSE
global DEBUG

VERBOSE = 0
DEBUG = 0

import ndctl as n
import fstab as f
from common import message, get_linenumber

# Dicts used
ndctl = {}
fstab = {}

dimm_list = []
skip_ndctl_dump = False

def check_user_is_root():
    status = False
    uid = os.getuid()
    if uid == 0:
        status = True
    else:
        print("You must either SUDO or be root to run this script")
        print("Your User ID:", uid)
    return bool(status)

def main(argv):
    # process command line arguments

    global VERBOSE
    global DEBUG

    ndctl_file = n.DEFAULT_NDCTL_FILE
    fstab_file = f.DEFAULT_FSTAB_FILE

    delimiter = '; '
    fsSuffix = ''

    ap = argparse.ArgumentParser()

    ap.add_argument("--delimiter", required=False, help="Delimiter for pmfs mount path. Default:';'")
    ap.add_argument("--suffix", required=False, help="string to append to pmfs mount path Default:''")
    ap.add_argument("--ndctl_file", required=False, help=" path to ndctl data file.  Default:''")
    ap.add_argument("--fstab_file", required=False, help="path to fstab file. Default:''")
    ap.add_argument("--sandbox", required=False, help="path to optional sandbox environment. Default:''")
    ap.add_argument("--skip_ndctl_dump", required=False, help="flag to control whether to create a new ndctl data file. default:'False'")
    ap.add_argument("--verbose", required=False, help="enable Verbose mode")
    ap.add_argument("--debug", required=False, help="enable debug mode")

    args = vars(ap.parse_args())


    if args['ndctl_file']:  ndctl_file = args['ndctl_file']
    if args['fstab_file']:  fstab_file = args['fstab_file']
    if args['delimiter']:  delimiter = args['delimiter']
    if args['suffix']:     fsSuffix = args['suffix']

    if args['sandbox']:
        sandbox_path = args['sandbox']
        os.environ['SANDBOX'] = sandbox_path
        ndctl_file = sandbox_path + n.DEFAULT_NDCTL_FILE
        fstab_file = sandbox_path + f.DEFAULT_FSTAB_FILE

    if args['verbose']:
        VERBOSE = args['verbose']
        n.VERBOSE = args['verbose']
        f.VERBOSE = args['verbose']

    if args['debug']:
        DEBUG = 1
        n.DEBUG = 1
        f.DEBUG = 1

    message("checking if current user is privileged", 1)
    if not check_user_is_root():
        message("No - not privileged", 1)
        sys.exit(1)
    else:
        message("Yes", 1)

    if os.path.exists(fstab_file):
        message("processing fstab data", 1)
        fstab = f.parse_fstab(fstab_file)
        message("done", 1)
    else:
        print("Error: missing fstab file:", fstab_file)
        sys.exit(3)

    if not fstab:
        message("\nFound no Persistent Memory Filesystems in fstab\n",0,'   ')
        message("Checked for fstab block device entries:",0,'   ')
        message("  starting with: /dev/disk/by-uuid/ with links to /dev/pmemX",0,'   ')
        message("  starting with: UUID= with links to /dev/pmemX",0,'   ')
        message("  starting with: /dev/pmem",0,'   ')
        message("\nPlease verifiy fstab contains PMFS entries\n",0,'   ')
        sys.exit(4)

    message("preparing ndctl data dump",1)
    if not skip_ndctl_dump:
        n.dump(ndctl_file)
        message("done",1)
    else:
        message("Skipped due to skip_ndctl_dump flag",1)


    message("parsing ndctl data dump",1)
    if os.path.exists(ndctl_file):
        ndctl = n.parse(ndctl_file)
        message("Finshed parsing ndcl data",1)
    else:
        print("Missing NDCTL data file:", ndctl_file)
        sys.exit(2)


    # get list of all pmem dimms in system
    message("generating list of dimms",1)
    dimm_list = n.get_dimm_list()
    dimm_list.sort()
    message("done",1)

    if VERBOSE: print("ndctl and fstab data merge start")
    message("",1)
    for dimm in dimm_list:
        status  = n.get_dimm_status(dimm)

        # get the list of namespace devices (pmemX) for this DIMM
        msg = "%s %s %s" % ("generating namespace device list for", dimm, '')
        message(msg,1)
        nsDevList = n.get_ns_device_list_by_dimm(dimm)
        msg = "%s %s %s" % ("ns device list", '', '')
        message(msg,1)

        # since DIMM status affects region status, which affects namespaces
        # on that region, we can use that status to infer the health of the namespace
        #
        # for each namespace device, update fs status with DIMM status
        msg = "%s %s %s" % ("updating namespace status from dimm status", '', '')
        message(msg,1)
        for dev in nsDevList:
            msg = "%s %s %s" % ("updating namespace status from dimm status", dev, status)
            message(msg,1)
            f.set_fs_status(fstab, dev, status)
        msg = "%s %s %s" % ("done", '', '')
        message(msg,1)

        msg = "%s %s %s" % ("updating fstab namespace region", dev, '')
        message("",1)
        region  = n.get_region_by_dimm(dimm)
        f.set_fs_region(fstab, dev, region)
        message("",1)
        msg = "%s %s %s" % ("", dev, '')
        # if VERBOSE: print("done")

        msg = "%s %s %s" % ("updating namespace dimm list", dev, '')
        message(msg,1)
        dList = n.get_region_dimm_list(region)
        dimms = ' '.join(dList)
        f.set_fs_dimms(fstab, dev, dimms)
        msg = "%s %s %s %s" % ("updated entry ", dev, ' with:', dimms)
        message(msg,1)

    message("ndctl and fstab data merge complete",1)
    message("Sending Reports",1)

    n.list_dimm_table()

    print()
    f.print_fstab_table(fstab)
    print()

    suffix = fsSuffix + delimiter
    print("\nPMFS with OK status: ", end='')
    f.print_fs_mounts(fstab,'ok', suffix)

if __name__ == "__main__":
    main(sys.argv[1:])
